---
title: "R Notebook"
output: html_notebook
---

```{r}
library(dplyr)
library(basedosdados)

# projeto google cloud
set_billing_id("absolute-text-417919")
```

## Setup

Lendo o query que defina tabelas de GPS, GTFS, e faz as manipulações, tudo com `with ... as`

```{r}
query <- readr::read_file("identificacao_pontos.sql")

start_date <- "\"2024-03-01\""

end_date <- "\"2024-03-02\""

query <- query %>%
    gsub("\\{start_date\\}", start_date, .) %>%
    gsub("\\{end_date\\}", end_date, .)
```

## Lendo bases do GTFS

-   Tabela com todos os dias

```{sql, eval = FALSE}
with Dates as (
    select data
    from UNNEST(
        GENERATE_DATE_ARRAY(DATE('2023-01-01'), CURRENT_DATE(), INTERVAL 1 DAY)
    ) as data
),
```

As tabelas do GTFS vêm com intervalos de `feed_start_date` a `feed_end_date`, não com uma observação por data. Então uso a tabela de datas para dar join nas linhas que entram no intervalo:

```{sql, eval = FALSE}
Stops as (
    select data, stop_id, stop_lat, stop_lon
    from `rj-smtr.gtfs.stops` s
        inner join Dates
            on (Dates.data between feed_start_date and feed_end_date) or
                (feed_end_date is null and Dates.data >= feed_start_date)
    where data between {start_date} and {end_date}
),
```

Faço o mesmo para todas as tabelas abaixo.

-   Paradas dos ônibus

```{r, message = FALSE}
stops <- read_sql(
    paste(query, "select * from Stops")
)

stops
```

-   Paradas dos ônibus linkadas com viagens

```{r, message = FALSE}
stop_times <- read_sql(
    paste(query, "select * from StopTimes")
)

stop_times
```

-   Viagens linkadas com rotas e shapes

```{r, message = FALSE}
trips <- read_sql(
    paste(query, "select * from Trips")
)

trips
```

-   Vértices de cada shape

```{r, message = FALSE}
shapes <- read_sql(
    paste(query, "select * from Shapes")
)

shapes
```

-   Geometria de cada shape

```{r, message = FALSE}
shapes_geom <- read_sql(
    paste(query, "select * from ShapesGeom")
)

shapes_geom %>%
    mutate(across(c("shape", "start_pt", "end_pt"), as.character))
```

-   Código de serviço de cada route_id

```{r, message = FALSE}
routes <- read_sql(
    paste(query, "select * from Routes")
)

routes
```

## Join das bases do GTFS

### Paradas

Primeiro dou join de Trips em StopTimes, para ter os pontos de cada route_id

```{sql, eval = FALSE}
TripStops as (
    select distinct data, route_id, shape_id, stop_id, stop_sequence, dist_traveled_stop
    from Trips
        left join StopTimes using(trip_id, data)
),
```

```{r, message = FALSE}
read_sql(
    paste(query, "select * from TripStops")
)
```

Agora uso as route_ids para obter os serviços, e as stop_ids para obter as coordenadas das paradas.

```{sql, eval = FALSE}
GTFSStops as (
    select distinct data, stop_id, shape_id, servico, stop_lat, stop_lon, stop_sequence, dist_traveled_stop
    from TripStops
        left join Routes using(route_id, data)
        left join Stops using(stop_id, data)
),
```

```{r, message = FALSE}
stops <- read_sql(
    paste(query, "select * from GTFSStops")
)

stops
```

### Itinerários

Pego as shape_ids possíveis de cada route_id. Se incluísse as geometrias de cara, não conseguiria dar distint para cada rota.

```{sql, eval = FALSE}
TripShapes as (
    select distinct data, route_id, shape_id
    from Trips
        left join ShapesGeom using(shape_id, data)
),
```

Então o código de cada serviço

```{sql, eval = FALSE}
GTFSServShapes as (
    select distinct data, shape_id, servico
    from TripShapes
        left join Routes using(route_id, data)
        
),
```

E ponho as shapes de volta

```{sql, eval = FALSE}
GTFSShapes as (
    select data, shape_id, servico, shape, start_pt, end_pt
    from GTFSServShapes
        left join ShapesGeom using(shape_id, data)
),
```

```{r, message = FALSE}
shapes <- read_sql(
    paste(query, "select * from GTFSShapes")
)

shapes %>%
    mutate(across(c("shape", "start_pt", "end_pt"), as.character))
```

## Lendo a base de GPS

Leio apenas as variáveis que interessam, para as datas escolhidas, e com ônibus em operação.

```{sql, eval = FALSE}
GPS as (
    select timestamp_gps, data, hora, servico, latitude, longitude, flag_em_movimento,
        tipo_parada, flag_trajeto_correto, velocidade_instantanea, velocidade_estimada_10_min,
        distancia, flag_em_operacao, id_veiculo
    from `rj-smtr.br_rj_riodejaneiro_veiculos.gps_sppo`
    where data between {start_date} and {end_date}
        and flag_em_operacao = TRUE
    order by servico, id_veiculo, timestamp_gps
),
```

```{r, message = FALSE}
gps <- read_sql(
    paste(query, "select * from GPS where servico = \'309\'")
)

gps
```

Dou join desta base nas geometrias possíveis para cada serviço (o que multiplica o número de obs. por \~2)

```{sql, eval = FALSE}
GPSShapes as (
    select *,
        ST_GEOGPOINT(longitude, latitude) posicao_veiculo_geo
    from GPS
        left join GTFSShapes using(servico, data)
),
```

```{r, message = FALSE}
gps <- read_sql(
    paste(query, "select * from GPSShapes where servico = \'309\'")
)

gps %>%
    mutate(across(c("shape", "start_pt", "end_pt", "posicao_veiculo_geo"), as.character))
```

## Identificando viagens

Para calcular a distância dos pontos, preciso primeiro saber qual shape_id os ônibus estão seguindo. Por isso, replico o código usado nos subsídios para identificar viagens. Uso `'endend'` no lugar de `'middleend'` porque quero jogar fora todas as observações em que uma viagem já acabou, e outra não começou.

```{sql, eval = FALSE}
GPSStatus as (
    select *,
        case
            when ST_DWITHIN(posicao_veiculo_geo, start_pt, 500)
                then 'start'
            when ST_DWITHIN(posicao_veiculo_geo, end_pt, 500)
                then 'end'
            when ST_DWITHIN(posicao_veiculo_geo, shape, 500)
                then 'middle'
            else 'out'
        end status_viagem
    from GPSShapes
),
        
-- marcando início e fim das viagens
        
GPSTrips as (
    select *,
        string_agg(status_viagem, "") over (
           partition by id_veiculo, shape_id
           order by id_veiculo, shape_id, timestamp_gps
           rows between current row and 1 following) = 'startmiddle' starts,
        string_agg(status_viagem, "") over (
           partition by id_veiculo, shape_id
           order by id_veiculo, shape_id, timestamp_gps
           rows between 1 preceding and current row) = 'endend' ended
    from GPSStatus
),
```

Crio uma id_viagem: é um número qualquer quando uma viagem começa; 0 quando já terminou; e null caso contrário.

```{sql, eval = FALSE}
GPSTripsId as (
    select *,
        case
           when starts = true
               then ROW_NUMBER() over(order by (select 1))
           when ended = true
               then 0
           else null
        end pre_id_viagem
    from GPSTrips
),
```

Agora estendo as id_viagens de cima pra baixo: se uma viagem começou nas observações anteriores e tudo em seguida é null, marco como a mesma viagem. Só para quando chega em um 0, no final da viagem.

```{sql, eval = FALSE}
GPSTripsId2 as (
    select *,
        count(pre_id_viagem) over(
            partition by id_veiculo, shape_id
            order by id_veiculo, shape_id, timestamp_gps)
        as _grp
    from GPSTripsId
),
        
GPSTripsId3 as (
    select *,
        FIRST_VALUE(pre_id_viagem) over(
            partition by id_veiculo, shape_id, _grp
            order by id_veiculo, shape_id, timestamp_gps)
        as id_viagem
    from GPSTripsId2
),
```

E apenas mantenho observações com viagens em curso e identificadas.

```{sql, eval = FALSE}
GPSTripsId4 as (
    select * from GPSTripsId3
    where id_viagem is not null and id_viagem != 0
),
```

```{r, message = FALSE}
gps <- read_sql(
    paste(query, "select * from GPSTripsId4 where servico = \'309\'")
)

gps %>%
    mutate(across(c("shape", "start_pt", "end_pt", "posicao_veiculo_geo"), as.character))
```

## Identificando quando o ônibus chega a um ponto

Dando join na base de pontos de ônibus (multiplica por muitas vezes as linhas, cada serviço tem vários pontos)

```{sql, eval = FALSE}
GPSStops as (
    select *,
        ST_GEOGPOINT(stop_lon, stop_lat) stop_geo
    from GPSTripsId4
        left join GTFSStops using(data, servico, shape_id)
),
```

Calculo a distância entre cada ônibus e cada ponto

```{sql, eval = FALSE}
GPSStops2 as (
    select *,
        ST_DISTANCE(posicao_veiculo_geo, stop_geo) as distancia_ponto
    from GPSStops
),
```

Crio uma base auxiliar onde mantenho o ponto mais próximo. Dou inner join para manter apenas os pontos mais próximos na base de GPS, com sua distância.

```{sql, eval = FALSE}
GPSStopsClosest as (
    select id_veiculo, shape_id, timestamp_gps, MIN(distancia_ponto) as distancia_ponto
    from GPSStops2
    group by id_veiculo, shape_id, timestamp_gps
),
        
GPSStops3 as (
    select *
    from GPSStops2
        inner join GPSStopsClosest using(distancia_ponto, id_veiculo, shape_id, timestamp_gps)
),
```

Se o ônibus está a 50m de seu ponto mais próximo, declaro que ele está no ponto. Caso contrário, o ponto é `'none'`.

```{sql, eval = FALSE}
GPSStops4 as (
    select *,
        case
           when distancia_ponto <= 50
               then stop_id
           else 'none'
        end stop
    from GPSStops3
),
```

```{r, message = FALSE}
gps <- read_sql(
    paste(query, "select * from GPSStops4 where servico = \'309\'")
)

gps %>%
    mutate(across(c("shape", "start_pt", "end_pt", "posicao_veiculo_geo", "stop_geo"), as.character))
```

## Calculando tempo de chegada ao ponto seguinte

Calculo o ponto anterior, `previous_stop`. Pode ser `'none'` ou alguma stop_id.

```{sql, eval = FALSE}
GPSStops5 as (
    select *,
        LAG(stop) over(
            partition by id_veiculo, shape_id
            order by id_veiculo, shape_id, timestamp_gps)
        as previous_stop
    from GPSStops4
),
```

Quando o ponto atual é diferente do anterior e o atual não é `'none'`, declaro que o ônibus chegou a um ponto. Marco a hora de chegada na variável `pre_arrival_time`.

```{sql, eval = FALSE}
GPSStops6 as (
    select *,
        case
           when stop != previous_stop and stop != 'none'
               then timestamp_gps
           else null
        end pre_arrival_time
    from GPSStops5
),
```

Estendo esses valores de baixo pra cima (por isso os `desc`s), de modo que se um ônibus chegou às 13h no ponto, se na observação anterior ele não tiver chegado, seu tempo de chegada também fica marcado como 13h.

```{sql, eval = FALSE}
GPSStops7 as (
    select *,
        count(pre_arrival_time) over(
            partition by id_veiculo, shape_id
            order by id_veiculo, shape_id, timestamp_gps)
        as _grp2
    from GPSStops6
),
        
GPSStops8 as (
    select *,
        LAST_VALUE(pre_arrival_time) over(
            partition by id_veiculo, shape_id, _grp2
            order by id_veiculo, shape_id, timestamp_gps)
        as pre_arrival_time2
    from GPSStops7
        ),
```

Vendo se, de fato, os tempos de chegada fazem sentido: `pre_arrival_time` é cheio de `null`s, e `pre_arrival_time2` é a versão preenchida.

```{r, message = FALSE}
gps <- read_sql(
    paste(query, "select * from GPSStops8 where servico = \'309\'")
)

gps %>%
    mutate(across(c("shape", "start_pt", "end_pt", "posicao_veiculo_geo", "stop_geo"), as.character)) %>%
    arrange(id_veiculo, timestamp_gps)
```

Quando o ônibus está em um ponto, o momento de chegada é a hora atual. Mudo para que seja a hora de chegada no ponto seguinte.

```{sql, eval = FALSE}
GPSStops9 as (
    select *,
        LEAD(pre_arrival_time2) over(
            partition by id_veiculo, shape_id
            order by id_veiculo, shape_id, timestamp_gps)
        as lead_arrival_time
    from GPSStops8
    where pre_arrival_time2 is not null
),
        
GPSStops10 as (
    select *,
        case
           when pre_arrival_time2 = timestamp_gps
               then lead_arrival_time
           else pre_arrival_time2
        end pre_arrival_time3
    from GPSStops9
),
```

Então calculo `arrival_time` como a diferença entre a hora de chegada no ponto seguinte e a hora atual, medida em minutos.

```{sql, eval = FALSE}
GPSStops11 as (
    select * except(stop_lon, stop_lat),
        DATETIME_DIFF(pre_arrival_time3, timestamp_gps, MICROSECOND)/(60 * 1000000) as arrival_time
    from GPSStops10
),
```

E a base final, com os tempos de chegada. Mantenho apenas observações em que conseguir medir o tempo de chegada -- quando o ônibus eventualmente chega a um ponto -- e sobram quase todas.

```{r, message = FALSE}
gps <- read_sql(
    paste(query, "select * from GPSStops11 where servico = \'309\'")
)

gps %>%
    mutate(across(c("shape", "start_pt", "end_pt", "posicao_veiculo_geo", "stop_geo"), as.character))
```

## Calculando distância viajada até o momento

Até agora, só temos a base original com as coordenadas, acrescida dos minutos até chegar ao próximo ponto. Para previsão, já que temos as velocidades, é melhor que tenhamos as distâncias, já que o tempo depende de forma muito não-linear da latitude e longitude.

Para ter a distância que o ônibus viajou até o momento, dou join na tabela de Shapes, que tem os vértices do itinerário. Encontro o vértice mais próximo do ônibus e uso a distância do início até ele como a distância total viajada pelo ônibus. Isso nos dá a variável `dist_traveled_shape`.

```{sql, eval = FALSE}
GPSStops12 as (
    select *,
    ST_GEOGPOINT(shape_pt_lon, shape_pt_lat) shape_pt_geo
    from GPSStops11
        left join Shapes using(data, shape_id)
),

-- calculando distancias
        
GPSStops13 as (
    select *,
        ST_DISTANCE(posicao_veiculo_geo, shape_pt_geo) as distancia_shape
    from GPSStops12
),
        
---- mantendo o ponto mais próximo
        
GPSStopsClosest2 as (
    select id_veiculo, shape_id, timestamp_gps, MIN(distancia_shape) as distancia_shape
    from GPSStops13
    group by id_veiculo, shape_id, timestamp_gps
),
        
GPSStops14 as (
    select *
    from GPSStops13
        inner join GPSStopsClosest2 using(distancia_shape, id_veiculo, shape_id, timestamp_gps)
)
```

```{r, message = FALSE}
gps <- read_sql(
    paste(query, "select * from GPSStops14 where servico = \'309\'")
)

gps %>%
    mutate(across(
        c("shape", "start_pt", "end_pt", "posicao_veiculo_geo", "stop_geo", "shape_pt_geo"),
        as.character
        )
    )
```

## Calculando distância viajada até o ponto seguinte

```{sql, eval = FALSE}
GPSStops15 as (
    select timestamp_gps, g.data as data, hora, g.servico as servico, latitude,
        longitude, flag_em_movimento, g.stop_sequence as stop_sequence,
        tipo_parada, flag_trajeto_correto, velocidade_instantanea, velocidade_estimada_10_min,
        id_veiculo, id_viagem, stop, arrival_time, dist_traveled_shape,
        s.dist_traveled_stop as dist_traveled_next_stop
    from GPSStops14 g
        left join GTFSStops s
            on g.data = s.data and g.servico = s.servico and g.shape_id = s.shape_id and g.stop_sequence = s.stop_sequence - 1
),
      
GPSStops16 as (
    select *,
        dist_traveled_next_stop - dist_traveled_shape as dist_next_stop
    from GPSStops15
)

```

```{r, message = FALSE}
gps <- read_sql(
    paste(query, "select * from GPSStops16 where servico = \'309\'")
)

gps %>%
    mutate(across(
        c("next_stop_geo"),
        as.character
        )
    )
```