---
title: "R Notebook"
output: html_notebook
---

```{r}
# Show all the code chunks and their output
knitr::opts_chunk$set(echo = TRUE)
```

# Introdução

Primeiro, vamos carregar os pacotes necessários para a análise.

```{r setup, include=FALSE}
# Hide library messages and warnings
options(warn=-1)
options(message=-1)

library(mgcv)
library(readr)
library(dplyr)
library(ggplot2)
library(gridExtra)
```

Agora, vamos carregar os dados localizados em 'data/409_train_data.csv'.

```{r}
data <- read_csv("data/409_train_data.csv")

# Print the first 6 rows of the data
head(data)
```


# Tratamento dos dados

Primeiro, vamos remover as colunas que não são necessárias para a análise e remover todos os dados fora da rota.

```{r}
# Select only the columns that are necessary for the analysis ('data', 'hora', 'id_veiculo', 'servico', 'velocidade_estimada_10_min', 'in_route', 'direction', 'distance_traveled', 'cumulative_time_traveled', 'mean_speed_1_min', 'mean_speed_3_min', 'mean_speed_5_min'
data <- data %>% select(data, hora, id_veiculo, servico, velocidade_estimada_10_min, in_route, direction, distance_traveled, time_traveled, mean_speed_1_min, mean_speed_3_min, mean_speed_5_min)

# Remove all the data that is not in the route
data <- data %>% filter(in_route == TRUE)

# Remove all data that the direction is not 0 or 1
data <- data %>% filter(direction == 0 | direction == 1)

# Make the "hora" column have the correct format
data$hora <- as.POSIXct(data$hora, tz = "UTC")

# Make the "data" column have the correct format
data$data <- as.Date(data$data)

# Add week day column
data$week_day <- weekdays(data$data)

# Make the week_day column a factor with the levels in the correct order
data$week_day <- factor(data$week_day, levels = c("domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sábado"))

# Add is_weekend column
data$is_weekend <- ifelse(data$week_day == "sábado" | data$week_day == "domingo", TRUE, FALSE)

# Add time_period column
data$time_period <- cut(as.numeric(format(as.POSIXct(data$hora, tz = "UTC"), "%H")), breaks = c(0, 6, 12, 18, 24), labels = c("Dawn", "Morning", "Afternoon", "Night"))

# Print the first 6 rows of the data
head(data)
```


Agora, remover-se-á os dados em que o veículo não tenha percorrido mais de 100 metros da linha. Além disso, é preciso definir um identificador único para cada viagem (trip) que será incrementado cada vez que a direção do veículo mudar. Com isso, será possível identificar cada viagem de forma única e considerar que o ínicío de uma viagem é quando o veículo percorreu mais de 100 metros da linha.


```{r}
# Remove all the data that the vehicle has not traveled more than 100 meters
filtered_data <- data %>% filter(distance_traveled > 100)

# Create a new column called 'trip_id' that will be incremented each time the direction changes group by vehicle or more than 5 minutes have passed
filtered_data <- filtered_data %>% group_by(id_veiculo, data) %>% mutate(trip_id = cumsum(direction != lag(direction, default = first(direction)) | time_traveled > 600))

# Remove trips that have less than 10 data points
filtered_data <- filtered_data %>% group_by(id_veiculo, trip_id, data) %>% filter(n() > 10)

# Recalculate trip_id after removing trips with less than 10 data points
filtered_data <- filtered_data %>% group_by(id_veiculo, data) %>% mutate(trip_id = cumsum(direction != lag(direction, default = first(direction))))

# Get all data that the dstance traveled was decreased from the previous data point (with a 100 meters threshold)
wrong_direction_data <- filtered_data %>% group_by(id_veiculo, trip_id) %>% filter(distance_traveled < lag(distance_traveled, default = first(distance_traveled)) - 100)

# Filter wrong direction data to remove trips with less than 5 data points
wrong_direction_data <- wrong_direction_data %>% group_by(id_veiculo, trip_id, data) %>% filter(n() > 5)

# Get the trip_id of the wrong direction data
wrong_direction_trip_id <- wrong_direction_data %>% select(id_veiculo, trip_id) %>% distinct()

# Remove all the wrong direction data
filtered_data <- filtered_data %>% anti_join(wrong_direction_trip_id, by = c("id_veiculo", "trip_id"))

# Add cumulative time traveled column for each trip
filtered_data <- filtered_data %>% group_by(id_veiculo, trip_id, data) %>% mutate(time_traveled_trip = cumsum(time_traveled))

# Recalculate trip_id after removing wrong direction data
filtered_data <- filtered_data %>% group_by(id_veiculo, data) %>% mutate(trip_id = cumsum(direction != lag(direction, default = first(direction)) | hora - lag(hora, default = first(hora)) > 300))

# Normalize the time traveled to start at 0 for each trip
filtered_data <- filtered_data %>% group_by(id_veiculo, trip_id, data) %>% mutate(time_traveled_trip = time_traveled_trip - min(time_traveled_trip))
```


```{r}
# Get trips that the distance traveled was almost the same for more than 20 data points (10 minutes)
data_points_number <- 20
treshold <- 100
dead_trips <- filtered_data
for (i in 1:data_points_number) {
  dead_trips <- dead_trips %>% group_by(id_veiculo, trip_id, data) %>% filter(abs(lead(distance_traveled, i) - distance_traveled) < treshold)
}
dead_trips <- dead_trips %>% select(id_veiculo, trip_id, data) %>% distinct()

# Get all the dead trips data
dead_trips_data <- filtered_data %>% inner_join(dead_trips, by = c("id_veiculo", "trip_id", "data"))

# Plot a scatter plot of time traveled vs distance traveled for the dead trips data
plot_dead_trips <- dead_trips_data %>% ggplot(aes(x = time_traveled_trip, y = distance_traveled, color = id_veiculo)) +
  geom_point() +
  labs(title = "Time traveled vs Distance traveled", x = "Time traveled (s)", y = "Distance traveled (m)")

plot_dead_trips
```

```{r}
# Get trips that the beggining (first minute) of the trip has a distance traveld greater than 2000 meters
middle_trips <- filtered_data %>% group_by(id_veiculo, trip_id) %>% filter(time_traveled_trip < 60 & distance_traveled > 2000) %>% select(id_veiculo, trip_id, data) %>% distinct()

# Get all the middle trips data
middle_trips_data <- filtered_data %>% inner_join(middle_trips, by = c("id_veiculo", "trip_id", "data"))

# Plot a scatter plot of time traveled vs distance traveled for the middle trips data
plot_middle_trips <- middle_trips_data %>% ggplot(aes(x = time_traveled_trip, y = distance_traveled, color = trip_id)) +
  geom_point() +
  labs(title = "Time traveled vs Distance traveled", x = "Time traveled (s)", y = "Distance traveled (m)")

plot_middle_trips
```

```{r}
# Remove all the dead trips data
filtered_data <- filtered_data %>% anti_join(dead_trips, by = c("id_veiculo", "trip_id", "data"))

# Remove all the middle trips data
filtered_data <- filtered_data %>% anti_join(middle_trips, by = c("id_veiculo", "trip_id", "data"))

# Plot a scatter plot of time traveled vs distance traveled for the filtered data
plot_filtered_data <- filtered_data %>% ggplot(aes(x = time_traveled_trip, y = distance_traveled, color = id_veiculo)) +
  geom_point() +
  labs(title = "Time traveled vs Distance traveled", x = "Time traveled (s)", y = "Distance traveled (m)")

plot_filtered_data
```

# Análise exploratória

Primeiramente, vamos analisar a distribuição das velocidades estimadas a cada 1, 3, 5 e 10 minutos.

```{r}
# Create a plot for the mean speed at 1 minute
p1 <- ggplot(filtered_data, aes(x = mean_speed_1_min)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  labs(title = "Mean speed at 1 minute", x = "Mean speed (km/h)", y = "Frequency")

# Create a plot for the mean speed at 3 minutes
p2 <- ggplot(filtered_data, aes(x = mean_speed_3_min)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  labs(title = "Mean speed at 3 minutes", x = "Mean speed (km/h)", y = "Frequency")

# Create a plot for the mean speed at 5 minutes
p3 <- ggplot(filtered_data, aes(x = mean_speed_5_min)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  labs(title = "Mean speed at 5 minutes", x = "Mean speed (km/h)", y = "Frequency")

# Create a plot for the mean speed at 10 minutes
p4 <- ggplot(filtered_data, aes(x = velocidade_estimada_10_min)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  labs(title = "Mean speed at 10 minutes", x = "Mean speed (km/h)", y = "Frequency")

# Combine all the plots
grid.arrange(p1, p2, p3, p4, ncol = 2)
```

É possível observar qur as velocidades estimadas a cada 1, 3 e 5 minutos possuem muitos outliers, o que pode ser um problema para a análise. Portanto, as velocidades estimadas a cada 1, 3 e 5 minutos serão clipadas entre 0 e 60 km/h assim como a velocidade estimada a cada 10 minutos.

```{r}
# Clip the mean speed at 1 minute between 0 and 60 km/h
filtered_data$mean_speed_1_min <- pmin(pmax(filtered_data$mean_speed_1_min, 0), 60)

# Clip the mean speed at 3 minutes between 0 and 60 km/h
filtered_data$mean_speed_3_min <- pmin(pmax(filtered_data$mean_speed_3_min, 0), 60)

# Clip the mean speed at 5 minutes between 0 and 60 km/h
filtered_data$mean_speed_5_min <- pmin(pmax(filtered_data$mean_speed_5_min, 0), 60)

# Get the y-axis limits to the maximum bin count
max_bin_count <- max(hist(filtered_data$mean_speed_1_min, breaks = 30, plot = FALSE)$counts, hist(filtered_data$mean_speed_3_min, breaks = 30, plot = FALSE)$counts, hist(filtered_data$mean_speed_5_min, breaks = 30, plot = FALSE)$counts, hist(filtered_data$velocidade_estimada_10_min, breaks = 30, plot = FALSE)$counts)

# Plot again the mean speed at 1, 3, 5 and 10 minutes
p1 <- ggplot(filtered_data, aes(x = mean_speed_1_min)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  labs(title = "Mean speed at 1 minute", x = "Mean speed (km/h)", y = "Frequency") +
  ylim(0, max_bin_count*1.1)

p2 <- ggplot(filtered_data, aes(x = mean_speed_3_min)) +
    geom_histogram(bins = 30, fill = "blue", color = "black") +
    labs(title = "Mean speed at 3 minutes", x = "Mean speed (km/h)", y = "Frequency") +
    ylim(0, max_bin_count*1.1)

p3 <- ggplot(filtered_data, aes(x = mean_speed_5_min)) +
    geom_histogram(bins = 30, fill = "blue", color = "black") +
    labs(title = "Mean speed at 5 minutes", x = "Mean speed (km/h)", y = "Frequency") +
    ylim(0, max_bin_count*1.1)

p4 <- ggplot(filtered_data, aes(x = velocidade_estimada_10_min)) +
    geom_histogram(bins = 30, fill = "blue", color = "black") +
    labs(title = "Mean speed at 10 minutes", x = "Mean speed (km/h)", y = "Frequency") +
    ylim(0, max_bin_count*1.1)


grid.arrange(p1, p2, p3, p4, ncol = 2)
```

Agora, observaremos a quantidade de dados e a quantidade de viagens por veículo.

```{r}
# Create a histogram for the number of data points per vehicle
plot_data_per_vehicle <- filtered_data %>% group_by(id_veiculo) %>% summarise(n = n()) %>% ggplot(aes(x = n)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  labs(title = "Frequency of vehicles by number of data points", x = "Number of data points", y = "Frequency")

# Create a histogram for the number of trips per vehicle
plot_trips_per_vehicle <- filtered_data %>% group_by(id_veiculo) %>% summarise(n = n_distinct(trip_id)) %>% ggplot(aes(x = n)) +
  geom_histogram(bins = 30, fill = "blue", color = "black") +
  labs(title = "Frequency of vehicles by number of trips", x = "Number of trips", y = "Frequency")

# Combine the plots
grid.arrange(plot_data_per_vehicle, plot_trips_per_vehicle, nrow = 2)
```

Agora, vamos analisar a distribuição entre o tempo de viagem e a distância percorrida.

```{r}
# Create a scatter plot for the time traveled and the distance traveled colored by vehicle id
plot_time_distance <- filtered_data %>% ggplot(aes(x = time_traveled_trip, y = distance_traveled, color = id_veiculo)) +
  geom_point() +
  labs(title = "Time traveled vs Distance traveled", x = "Time traveled (s)", y = "Distance traveled (m)")

plot_time_distance
```


# Modelagem

Agora, vamos ajustar um modelo de regressão linear generalizada para prever o tempo de viagem com base na distância percorrida. Primeiramente, vamos ajustar um modelo linear simples.

```{r}
# Fit a linear model to predict the time traveled based on the distance traveled
linear_model <- glm(time_traveled_trip ~ distance_traveled, data = filtered_data)

# Print the summary of the linear model
summary(linear_model)
```

O modelo linear simples ajustado possui um R² de 0.7712, o que indica que a distância percorrida explica 77.12% da variabilidade no tempo de viagem. Além disso, o p-valor associado ao coeficiente da distância percorrida é menor que 0.05, o que indica que a distância percorrida é estatisticamente significativa para prever o tempo de viagem.

Agora, dado que a direção do veículo pode influenciar o tempo de viagem, vamos ajustar um modelo de regressão linear generalizada com um termo de interação entre a distância percorrida e a direção.

```{r}
# Fit a generalized linear model to predict the time traveled based on the distance traveled and the direction
interaction_model <- glm(time_traveled_trip ~ distance_traveled * direction, data = filtered_data)

# Print the summary of the interaction model
summary(interaction_model)
```

O modelo de interação ajustado possui um R² de 0.8089, o que tem um desempenho ligeiramente melhor do que o modelo linear simples. Além disso, o p-valor associado a todos os coeficientes é menor que 0.05, o que indica que a distância percorrida, a direção e a interação entre a distância percorrida e a direção são estatisticamente significativas para prever o tempo de viagem.

Agora, vamos adicionar a velocidade média estimada a cada 10 minutos como uma variável independente no modelo.

```{r}
# Fit a generalized linear model to predict the time traveled based on the distance traveled, the direction, and the mean speed at 10 minutes
speed_model <- glm(time_traveled_trip ~ distance_traveled * direction + velocidade_estimada_10_min, data = filtered_data)

# Print the summary of the speed model
summary(speed_model)
```

O modelo de velocidade ajustado possui um R² de 0.8368, um resultado melhor do que os modelos anteriores. Além disso, o modelo jugou todas as variáveis estatisticamente significativas para prever o tempo de viagem.

Agora, vamos observar a relação entre o tempo de viagem previsto pelo modelo e o tempo de viagem real.

```{r}
# Predict the time traveled using the speed model
filtered_data$predicted_time_traveled <- predict(speed_model, newdata = filtered_data)

# Create a scatter plot for the predicted time traveled and the real time traveled
plot_predicted_time <- filtered_data %>% ggplot(aes(x = time_traveled_trip, y = predicted_time_traveled)) +
  geom_point(color = "blue") +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(title = "Real time traveled vs Predicted time traveled", x = "Real time traveled (s)", y = "Predicted time traveled (s)")

plot_predicted_time
```

Plotando os erros do modelo em boxplots para cada intervalo de 250 metros percorridos.

```{r}
# Calculate the errors of the model
filtered_data$error <- filtered_data$time_traveled_trip - filtered_data$predicted_time_traveled

# Create a boxplot for the errors of the model for each interval of 500 meters traveled
plot_errors <- filtered_data %>% filter(distance_traveled <= 10000) %>% ggplot(aes(x = cut(distance_traveled, breaks = seq(0, 10000, by = 500)), y = error)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the model for each interval of 500 meters traveled", x = "Distance traveled (m)", y = "Error (s)") + ylim(-1200, 1200)

plot_errors
```

Agora, para garantir que os tempos de viagem previstos pelo modelo sejam positivos, vamos ajustar um modelo de regressão linear generalizada com uma distribuição gama.

```{r}
# Forces 0 time traveled to be 1
filtered_data$time_traveled_trip[filtered_data$time_traveled_trip == 0] <- 1

# Fit a generalized linear model with a gamma distribution to predict the time traveled based on the distance traveled, the direction, and the mean speed at 10 minutes
gamma_model <- glm(time_traveled_trip ~ distance_traveled * direction + velocidade_estimada_10_min, data = filtered_data, family = "Gamma")

# Print the summary of the gamma model
summary(gamma_model)
```

O modelo gamma ajustado teve um AIC de 16258250 e todos os coeficientes foram estatisticamente significativos para prever o tempo de viagem.

Agora, vamos observar a relação entre o tempo de viagem previsto pelo modelo gamma e o tempo de viagem real.

```{r}
# Predict the time traveled using the gamma model
filtered_data$predicted_time_traveled_gamma <- predict(gamma_model, newdata = filtered_data, type = "response")

# Create a scatter plot for the predicted time traveled and the real time traveled
plot_predicted_time_gamma <- filtered_data %>% ggplot(aes(x = time_traveled_trip, y = predicted_time_traveled_gamma)) +
  geom_point(color = "blue") +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(title = "Real time traveled vs Predicted time traveled (gamma model)", x = "Real time traveled (s)", y = "Predicted time traveled (s)")

plot_predicted_time_gamma
```

Plotando os erros do modelo gamma em boxplots para cada intervalo de 500 metros percorridos.

```{r}
# Calculate the errors of the gamma model
filtered_data$error_gamma <- filtered_data$time_traveled_trip - filtered_data$predicted_time_traveled_gamma

# Create a boxplot for the errors of the gamma model for each interval of 500 meters traveled
plot_errors_gamma <- filtered_data %>% filter(distance_traveled <= 10000) %>% ggplot(aes(x = cut(distance_traveled, breaks = seq(0, 10000, by = 500)), y = error_gamma)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the gamma model for each interval of 500 meters traveled", x = "Distance traveled (m)", y = "Error (s)") + ylim(-1200, 1200)

plot_errors_gamma
```

Um problema com o modelo gamma é que ele pressupõe uma relação multiplicativa entre as variáveis independentes e a variável dependente, ou seja, não consegue capturar relações aditivas (como a relação linear entre a distância percorrida e o tempo de viagem). Logo, o modelo gamma pode não ser o mais adequado para prever o tempo de viagem então, voltaremos a ajustar um modelo de regressão linear generalizada com uma distribuição normal (basicamente, um modelo de regressão linear) realizando uma "clipagem" dos tempos de viagem previstos para serem positivos.

É de certa forma intuitivo que o comportamento do ônibus seja diferente para diferentes dias da semana e períodos do dia. Para verificar isso, podemos plotar os erros do modelo para cada dia da semana e período do dia, usando o modelo "speed_model".

```{r}
# Clip the predicted time traveled to be positive
filtered_data$predicted_time_traveled <- pmax(filtered_data$predicted_time_traveled, 0)
filtered_data$error <- filtered_data$time_traveled_trip - filtered_data$predicted_time_traveled

# Plot the errors of the model for each day of the week and time period
plot_errors_week_day <- filtered_data %>% ggplot(aes(x = week_day, y = error)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the model for each day of the week", x = "Day of the week", y = "Error (s)") + ylim(-2400, 2400)

plot_errors_time_period <- filtered_data %>% ggplot(aes(x = time_period, y = error)) +
    geom_boxplot(fill = "blue", color = "black") +
    labs(title = "Errors of the model for each time period", x = "Time period", y = "Error (s)") + ylim(-2400, 2400)

grid.arrange(plot_errors_week_day, plot_errors_time_period, nrow = 2)
```

É possível observar que os erros do modelo variam entre dias de semana e fins de semana, bem como entre períodos do dia. Portanto, é importante considerar essas variáveis ao ajustar o modelo.

Agora, vamos ajustar um modelo de regressão linear generalizada com uma distribuição normal que inclui a direção, a distância percorrida, a velocidade média estimada a cada 10 minutos e uma interação entre a distância percorrida, a direção e se é fim de semana ou não.

```{r}
# Fit a generalized linear model with a normal distribution to predict the time traveled based on the distance traveled, the direction, the mean speed at 10 minutes, and if it is weekend or not
weekend_model <- glm(time_traveled_trip ~ (distance_traveled + distance_traveled:direction)*is_weekend + velocidade_estimada_10_min, data = filtered_data, family = "gaussian")

# Print the summary of the weekend model
summary(weekend_model)
```

O modelo de fim de semana ajustado teve um AIC de 16449047 e todos os coeficientes foram estatisticamente significativos para prever o tempo de viagem.

Agora, vamos observar o erro do modelo para cada dia da semana e período do dia.

```{r}
# Add predicetd time traveled to the filtered data
filtered_data$predicted_time_traveled_weekend <- predict(weekend_model, newdata = filtered_data)

# Clip the predicted time traveled to be positive
filtered_data$predicted_time_traveled_weekend <- pmax(filtered_data$predicted_time_traveled_weekend, 0)

# Calculate the errors of the weekend model
filtered_data$error_weekend <- filtered_data$time_traveled_trip - filtered_data$predicted_time_traveled_weekend

# Plot the errors of the weekend model for each day of the week
plot_errors_week_day <- filtered_data %>% ggplot(aes(x = week_day, y = error_weekend)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the weekend model for each day of the week", x = "Day of the week", y = "Error (s)") + ylim(-2400, 2400)

plot_errors_week_day
```

Agora, vamos plotar, para cada dia da semana, o erro do modelo para cada intervalo de 500 metros percorridos.

```{r}
# Plot the errors of the weekend model for each day of the week and each interval of 500 meters traveled
plot_errors_week_day_distance <- filtered_data %>% filter(distance_traveled <= 10000) %>% ggplot(aes(x = cut(distance_traveled, breaks = seq(0, 10000, by = 500)), y = error_weekend)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the weekend model for each day of the week and each interval of 500 meters traveled", x = "Distance traveled (m)", y = "Error (s)") + ylim(-1200, 1200) + facet_wrap(~week_day)

plot_errors_week_day_distance
```

Agora, vamos plotar, para cada período do dia, o erro do modelo para cada dia da semana.

```{r}
# Plot the errors of the weekend model for each time period and each day of the week
plot_errors_time_period_week_day <- filtered_data %>% ggplot(aes(x = week_day, y = error_weekend)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the weekend model for each time period and each day of the week", x = "Day of the week", y = "Error (s)") + ylim(-1200, 1200) + facet_wrap(~time_period)

plot_errors_time_period_week_day

```

É possível ver que há um enviesamento nos erros do modelo para diferentes períodos do dia, mas também há um comportamento diferente para dias de semana e fins de semana. Portanto, é importante considerar essas variáveis ao ajustar o modelo.

Agora, vamos ajustar um modelo de regressão linear generalizada com uma distribuição normal que inclui a direção, a distância percorrida, a velocidade média estimada a cada 10 minutos e uma interação entre a distância percorrida, a direção e se é fim de semana ou não e o período do dia.

```{r}
# Fit a generalized linear model with a normal distribution to predict the time traveled based on the distance traveled, the direction, the mean speed at 10 minutes, if it is weekend or not, and the time period
time_period_model <- glm(time_traveled_trip ~ (distance_traveled + distance_traveled:direction)*is_weekend + time_period + velocidade_estimada_10_min, data = filtered_data, family = "gaussian")

# Print the summary of the time period model
summary(time_period_model)
```

Plotando novamente o erro do modelo para cada dia da semana e período do dia.

```{r}
# Add predicetd time traveled to the filtered data
filtered_data$predicted_time_traveled_time_period <- predict(time_period_model, newdata = filtered_data)

# Calculate the errors of the time period model
filtered_data$error_time_period <- filtered_data$time_traveled_trip - filtered_data$predicted_time_traveled_time_period

# Plot the errors of the time period model for each day of the week
plot_errors_time_period_week_day <- filtered_data %>% ggplot(aes(x = week_day, y = error_time_period)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the time period model for each day of the week", x = "Day of the week", y = "Error (s)") + ylim(-2400, 2400) + facet_wrap(~time_period)

plot_errors_time_period_week_day
```

Plotando os erros do modelo para cada dia da semana para cada intervalo de 500 metros percorridos.

```{r}
# Plot the errors of the time period model for each day of the week and each interval of 500 meters traveled
plot_errors_time_period_week_day_distance <- filtered_data %>% filter(distance_traveled <= 10000) %>% ggplot(aes(x = cut(distance_traveled, breaks = seq(0, 10000, by = 500)), y = error_time_period)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the time period model for each day of the week and each interval of 500 meters traveled", x = "Distance traveled (m)", y = "Error (s)") + ylim(-1200, 1200) + facet_wrap(~week_day)

plot_errors_time_period_week_day_distance
```

Agora, vamos plotar a relação entre o tempo de viagem previsto pelo modelo e o tempo de viagem real para o modelo "time_period_model".

```{r}
# Create a scatter plot for the predicted time traveled and the real time traveled
plot_predicted_time_time_period <- filtered_data %>% ggplot(aes(x = time_traveled_trip, y = predicted_time_traveled_time_period)) +
  geom_point(color = "blue") +
  geom_abline(intercept = 0, slope = 1, color = "red") +
  labs(title = "Real time traveled vs Predicted time traveled (time period model)", x = "Real time traveled (s)", y = "Predicted time traveled (s)")

plot_predicted_time_time_period
```


```{r}
plot_errors_week_day_distance <- filtered_data %>% filter(distance_traveled <= 10000) %>% ggplot(aes(x = cut(distance_traveled, breaks = seq(0, 10000, by = 500)), y = error_time_period)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the weekend model for each day of the week and each interval of 500 meters traveled", x = "Distance traveled (m)", y = "Error (s)") + ylim(-1200, 1200) + facet_wrap(~week_day)

plot_errors_week_day_distance
```

Por fim, vamos observar algumas estatísticas do modelo "time_period_model".

```{r}
# Calculate the RMSE of the time period model
rmse_time_period <- sqrt(mean(filtered_data$error_time_period^2))

# Print the RMSE of the time period model
rmse_time_period

# Calculate the MAE of the time period model
mae_time_period <- mean(abs(filtered_data$error_time_period))

# Print the MAE of the time period model
mae_time_period

# Calculate the MAPE of the time period model
mape_time_period <- mean(abs(filtered_data$error_time_period/filtered_data$time_traveled))

# Print the MAPE of the time period model
mape_time_period

```

```{r}
# Plot the errors of the time period model for each day of the week and each interval of 500 meters traveled
plot_errors_time_period_week_day_distance <- filtered_data %>% filter(distance_traveled <= 5000) %>% ggplot(aes(x = cut(distance_traveled, breaks = seq(0, 5000, by = 500)), y = error_time_period)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the time period model for each day of the week and each interval of 500 meters traveled", x = "Distance traveled (m)", y = "Error (s)") + ylim(-1000, 1000) + facet_wrap(~week_day)

plot_errors_time_period_week_day_distance
```

Testando treinar o modelo apenas com os dados com distância percorrida menor que 5000 metros.

```{r}
# Fit a generalized linear model with a normal distribution to predict the time traveled based on the distance traveled, the direction, the mean speed at 10 minutes, if it is weekend or not, and the time period
time_period_model_5000 <- glm(time_traveled ~ (distance_traveled + distance_traveled:direction):is_weekend*time_period + (distance_traveled + distance_traveled:direction)*time_period + velocidade_estimada_10_min, data = filtered_data %>% filter(distance_traveled <= 5000), family = "gaussian")

# Print the summary of the time period model
summary(time_period_model_5000)
```

```{r}
# Calculate the errors of the time period model
filtered_data$error_time_period_5000 <- filtered_data$time_traveled - predict(time_period_model_5000, newdata = filtered_data)

# Plot the errors of day of the week for each interval of 500 meters traveled
plot_errors_time_period_week_day_distance <- filtered_data %>% filter(distance_traveled <= 5000) %>% ggplot(aes(x = cut(distance_traveled, breaks = seq(0, 5000, by = 500)), y = error_time_period_5000)) +
  geom_boxplot(fill = "blue", color = "black") +
  labs(title = "Errors of the time period model for each day of the week and each interval of 500 meters traveled", x = "Distance traveled (m)", y = "Error (s)") + ylim(-250, 250) + facet_wrap(~week_day)

plot_errors_time_period_week_day_distance

```

As métricas de erro do modelo "time_period_model_5000" são:

```{r}
# Calculate the RMSE of the time period model
rmse_time_period_5000 <- sqrt(mean(filtered_data$error_time_period_5000^2))

# Print the RMSE of the time period model
rmse_time_period_5000

# Calculate the MAE of the time period model
mae_time_period_5000 <- mean(abs(filtered_data$error_time_period_5000))

# Print the MAE of the time period model
mae_time_period_5000

# Calculate the MAPE of the time period model
mape_time_period_5000 <- mean(abs(filtered_data$error_time_period_5000/filtered_data$time_traveled))

# Print the MAPE of the time period model
mape_time_period_5000
```

```{r}
# Function that given a data set path to a csv file, returns the treated data
treat_data <- function(data_path, route) {
  # Load the data
  data <- read.csv(data_path)

  # Select only the columns that are necessary for the analysis ('data', 'hora', 'id_veiculo', 'servico', 'velocidade_estimada_10_min', 'in_route', 'direction', 'distance_traveled', 'cumulative_time_traveled', 'mean_speed_1_min', 'mean_speed_3_min', 'mean_speed_5_min'
  data <- data %>% select(data, hora, id_veiculo, servico, velocidade_estimada_10_min, in_route, direction, distance_traveled, time_traveled, mean_speed_1_min, mean_speed_3_min, mean_speed_5_min)

  # Transform the 'hora' column to a time format
  data$hora <- as.POSIXct(data$hora, format = "%H:%M:%S")

  # Make the "data" column have the correct format
  data$data <- as.Date(data$data)

  # Make the "id_veiculo" column a factor
  data$id_veiculo <- as.factor(data$id_veiculo)

  # Make the "servico" column a factor
  data$servico <- as.factor(data$servico)

  # Make the "in_route" column a boolean
  data$in_route <- as.logical(data$in_route)

  # Add week day column
  data$week_day <- weekdays(data$data)

  # Make the week_day column a factor with the levels in the correct order
  data$week_day <- factor(data$week_day, levels = c("domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sábado"))

  # Add is_weekend column
  data$is_weekend <- ifelse(data$week_day == "sábado" | data$week_day == "domingo", TRUE, FALSE)

  # Add time_period column
  data$time_period <- cut(as.numeric(format(as.POSIXct(data$hora, tz = "UTC"), "%H")), breaks = c(0, 6, 12, 18, 24), labels = c("Dawn", "Morning", "Afternoon", "Night"))

  print(paste("Data loaded for route", route, "with", nrow(data), "data points"))

  # Remove all the data that is not in the route
  data <- data %>% filter(in_route == TRUE)

  print(paste("Data filtered for route", route, "with", nrow(data), "data points in the route"))

  # Remove all data that the direction is not 0 or 1
  data <- data %>% filter(direction == 0 | direction == 1)

  # Remove all the data that the vehicle has not traveled more than 100 meters
  filtered_data <- data %>% filter(distance_traveled > 100)

  # Create a new column called 'trip_id' that will be incremented each time the direction changes group by vehicle or more than 5 minutes have passed
  filtered_data <- filtered_data %>% group_by(id_veiculo, data) %>% mutate(trip_id = cumsum(direction != lag(direction, default = first(direction)) | time_traveled > 600))

  # Remove trips that have less than 10 data points
  filtered_data <- filtered_data %>% group_by(id_veiculo, trip_id, data) %>% filter(n() > 10)

  # Recalculate trip_id after removing trips with less than 10 data points
  filtered_data <- filtered_data %>% group_by(id_veiculo, data) %>% mutate(trip_id = cumsum(direction != lag(direction, default = first(direction))))

  # Get all data that the dstance traveled was decreased from the previous data point (with a 100 meters threshold)
  wrong_direction_data <- filtered_data %>% group_by(id_veiculo, trip_id, data) %>% filter(distance_traveled < lag(distance_traveled, default = first(distance_traveled)) - 100)

  # Filter wrong direction data to remove trips with less than 5 data points
  wrong_direction_data <- wrong_direction_data %>% group_by(id_veiculo, trip_id, data) %>% filter(n() > 5)

  # Get the trip_id of the wrong direction data
  wrong_direction_trip_id <- wrong_direction_data %>% select(id_veiculo, trip_id, data) %>% distinct()

  # Remove all the wrong direction data
  filtered_data <- filtered_data %>% anti_join(wrong_direction_trip_id, by = c("id_veiculo", "trip_id", "data"))

  # Add cumulative time traveled column for each trip
  filtered_data <- filtered_data %>% group_by(id_veiculo, trip_id, data) %>% mutate(time_traveled_trip = cumsum(time_traveled))

  # Recalculate trip_id after removing wrong direction data
  filtered_data <- filtered_data %>% group_by(id_veiculo, data) %>% mutate(trip_id = cumsum(direction != lag(direction, default = first(direction)) | hora - lag(hora, default = first(hora)) > 300))

  # Normalize the time traveled to start at 0 for each trip
  filtered_data <- filtered_data %>% group_by(id_veiculo, trip_id, data) %>% mutate(time_traveled_trip = time_traveled_trip - min(time_traveled_trip))

  print(paste("Data treated for route", route, "with", nrow(filtered_data), "data points in correct direction"))

  # Get trips that the distance traveled was almost the same for more than 20 data points (10 minutes)
  data_points_number <- 20
  treshold <- 100
  dead_trips <- filtered_data
  for (i in 1:data_points_number) {
      dead_trips <- dead_trips %>% group_by(id_veiculo, trip_id, data) %>% filter(abs(lead(distance_traveled, i) - distance_traveled) < treshold)
  }
  dead_trips <- dead_trips %>% select(id_veiculo, trip_id, data) %>% distinct()

  print(paste(nrow(dead_trips), "dead trips found for route", route))

  # Get all the dead trips data
  dead_trips_data <- filtered_data %>% inner_join(dead_trips, by = c("id_veiculo", "trip_id", "data"))

  # Plot a scatter plot of time traveled vs distance traveled
  plot_dead_trips <- dead_trips_data %>% ggplot(aes(x = time_traveled_trip, y = distance_traveled, color = id_veiculo)) +
      geom_point() +
      labs(title = "Time traveled vs Distance traveled", x = "Time traveled (s)", y = "Distance traveled (m)")

  # Get trips that the beggining (first minute) of the trip has a distance traveld greater than 2000 meters
  middle_trips <- filtered_data %>% group_by(id_veiculo, trip_id, data) %>% filter(time_traveled_trip < 60 & distance_traveled > 2000) %>% select(id_veiculo, trip_id, data) %>% distinct()

  # Get all the middle trips data
  middle_trips_data <- filtered_data %>% inner_join(middle_trips, by = c("id_veiculo", "trip_id", "data"))

  # Plot a scatter plot of time traveled vs distance traveled for the middle trips data
  plot_middle_trips <- middle_trips_data %>% ggplot(aes(x = time_traveled_trip, y = distance_traveled, color = id_veiculo)) +
      geom_point() +
      labs(title = "Time traveled vs Distance traveled", x = "Time traveled (s)", y = "Distance traveled (m)")

  print(paste(nrow(middle_trips), "middle trips found for route", route))

  # Remove all the dead trips data
  filtered_data <- filtered_data %>% anti_join(dead_trips, by = c("id_veiculo", "trip_id", "data"))

  # Remove all the middle trips data
  filtered_data <- filtered_data %>% anti_join(middle_trips, by = c("id_veiculo", "trip_id", "data"))

  print(paste("In the end, there are", nrow(filtered_data), "data points for route", route))

  # Plot a scatter plot of time traveled vs distance traveled
  plot_time_distance <- filtered_data %>% ggplot(aes(x = time_traveled_trip, y = distance_traveled, color = id_veiculo)) +
      geom_point() +
      labs(title = "Time traveled vs Distance traveled", x = "Time traveled (s)", y = "Distance traveled (m)")

  # Clip the mean speed at 1 minute between 0 and 60 km/h
  filtered_data$mean_speed_1_min <- pmin(pmax(filtered_data$mean_speed_1_min, 0), 60)

  # Clip the mean speed at 3 minutes between 0 and 60 km/h
  filtered_data$mean_speed_3_min <- pmin(pmax(filtered_data$mean_speed_3_min, 0), 60)

  # Clip the mean speed at 5 minutes between 0 and 60 km/h
  filtered_data$mean_speed_5_min <- pmin(pmax(filtered_data$mean_speed_5_min, 0), 60)

  # Save plots in a file
  ggsave(paste0("plots/plot_dead_trips/", route, ".png"), plot_dead_trips)
  ggsave(paste0("plots/plot_middle_trips/", route, ".png"), plot_middle_trips)
  ggsave(paste0("plots/plot_time_distance/", route, ".png"), plot_time_distance)

  return(filtered_data)
}

# Get all file names in the data folder
file_names <- list.files("data/results_march_2024/train", full.names = TRUE)

# Treat all the data
for (file_name in file_names) {
  route <- strsplit(strsplit(file_name, "/")[[1]][4], "_")[[1]][1]
  filtered_data <- treat_data(file_name, route)
  write.csv(filtered_data, paste0("data/treated/train/", route, "_train_data_treated.csv"), row.names = FALSE)
}


# Function to evaluate the models and save the plots
evaluate_model <- function(data_path, route) {
  # Load the data
  data <- read.csv(data_path)

  # Order "week_day" as a factor
  data$week_day <- factor(data$week_day, levels = c("domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sábado"))

  # Fit a generalized linear model with a normal distribution to predict the time traveled based on the distance traveled, the direction, the mean speed at 10 minutes, if it is weekend or not, and the time period
  time_period_model <- glm(time_traveled_trip ~ (distance_traveled + distance_traveled:direction):is_weekend*time_period + (distance_traveled + distance_traveled:direction)*time_period + velocidade_estimada_10_min, data = data, family = "gaussian")

  # Calculate the errors of the time period model
  data$predicted_time_traveled <- predict(time_period_model, newdata = data)
  data$error_time_period <- data$time_traveled_trip - data$predicted_time_traveled

  # Plot the errors of the time period model for each day of the week
  plot_errors_time_period_week_day <- data %>% ggplot(aes(x = week_day, y = error_time_period)) +
    geom_boxplot(fill = "blue", color = "black") +
    labs(title = "Errors of the time period model for each day of the week", x = "Day of the week", y = "Error (s)") + ylim(-2400, 2400) + facet_wrap(~time_period)

  # Plot the errors of the time period model for each day of the week and each interval of 500 meters traveled
  plot_errors_week_day_distance <- data %>% filter(distance_traveled <= 5000) %>% ggplot(aes(x = cut(distance_traveled, breaks = seq(0, 5000, by = 500)), y = error_time_period)) +
    geom_boxplot(fill = "blue", color = "black") +
    labs(title = "Errors of the time period model for each day of the week and each interval of 500 meters traveled", x = "Distance traveled (m)", y = "Error (s)") + ylim(-300, 300) + facet_wrap(~week_day)

  # Plot predicted time vs real time
  plot_predicted_time_vs_observed <- data %>% ggplot(aes(x = time_traveled_trip, y = predicted_time_traveled)) +
        geom_point(color = "blue") +
        geom_abline(intercept = 0, slope = 1, color = "red") +
        labs(title = "Real time traveled vs Predicted time traveled (time period model)", x = "Real time traveled (s)", y = "Predicted time traveled (s)")

  # Save the plots
  ggsave(paste0("plots/plot_errors_time_period_week_day/", route, ".png"), plot_errors_time_period_week_day, height = 8, width = 15)
  ggsave(paste0("plots/plot_errors_week_day_distance/", route, ".png"), plot_errors_week_day_distance, height = 8, width = 20)
  ggsave(paste0("plots/plot_predicted_time_vs_observed/", route, ".png"), plot_predicted_time_vs_observed)

  # Get model AIC
  aic_time_period <- AIC(time_period_model)

  # Calculate the RMSE of the time period model
  rmse_time_period <- sqrt(mean(data$error_time_period^2))

  return(c(aic_time_period, rmse_time_period))
}

# Get all file names in the processed data folder
processed_file_names <- list.files("data/treated/train", full.names = TRUE)

# Iterate over all the processed files
for (file_name in processed_file_names) {
  route <- strsplit(strsplit(file_name, "/")[[1]][4], "_")[[1]][1]
  options(warn=-1)
  metrics <- evaluate_model(file_name, route)
  print(paste("Metrics for route", route, "are AIC:", metrics[1], "RMSE:", metrics[2]))
}

```
